name: Deploy to ECS with Blue/Green

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-southeast-2
  ECR_REPOSITORY: mercor-ecs-app
  ECS_SERVICE: mercor-ecs-app-service
  ECS_CLUSTER: mercor-ecs-app-cluster
  ECS_TASK_DEFINITION: mercor-ecs-app
  CODEDEPLOY_APPLICATION: mercor-ecs-app
  CODEDEPLOY_DEPLOYMENT_GROUP: mercor-ecs-app-deployment-group
  S3_BUCKET: mercor-ecs-app-codedeploy-artifacts-yds6fgs2

permissions:
  contents: read

jobs:

  validate-changes:
    name: Validate Changes
    runs-on: ubuntu-latest
    outputs:
      run_infra: ${{ steps.changes.outputs.infra }}
      run_code: ${{ steps.changes.outputs.code }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
    
    - uses: dorny/paths-filter@v3
      id: changes
      with:
        filters: |
          infra:
            - 'infra/**'
          code: 
            - '!infra/**'

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [validate-changes]
    if: needs.validate-changes.outputs.run_infra == 'true'
    outputs:
      ecr-repository: ${{ steps.tf-outputs.outputs.ecr_repository_url }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.12.0'
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ./infra
      run: terraform init

    - name: Terraform Validate
      working-directory: ./infra
      run: terraform validate

    - name: Terraform Plan
      working-directory: ./infra
      run: terraform plan

    - name: Terraform Apply
      working-directory: ./infra
      run: terraform apply -auto-approve

    - name: Get Terraform Outputs
      id: tf-outputs
      working-directory: ./infra
      run: terraform output -json

  build-and-deploy:
    name: Build and Deploy Application
    runs-on: ubuntu-latest
    needs: [validate-changes]
    if: needs.validate-changes.outputs.run_code == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v5
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3.11.1

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Generate Image Name
      id: generate
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        IMAGE_TAG=${GITHUB_SHA::8}
        echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "image-name=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"  >> $GITHUB_OUTPUT

    - name: Build and Push Docker image
      uses: docker/build-push-action@v6.18.0
      with:
        push: true
        tags: ${{ steps.generate.outputs.image-name }}
        file: Dockerfile
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
    
    - name: Get task definition
      run: |
          aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --query taskDefinition > task-definition.json

    - name: Render task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.ECR_REPOSITORY }}
        image: ${{ steps.generate.outputs.image-name }}
        environment-variables: |
          APP_VERSION=${{ steps.generate.outputs.image-tag }}
    
    - name: Register new ECS task definition revision
      id: register-task-def
      run: |
        NEW_TASK_DEF=$(aws ecs register-task-definition \
          --cli-input-json file://${{ steps.task-def.outputs.task-definition }} \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        echo "task-def-arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

    - name: Create and upload CodeDeploy artifacts
      id: codedeploy-artifacts
      run: |
        # Create appspec.yml for CodeDeploy
        cat > appspec.yml << EOF
        version: 0.0
        Resources:
          - TargetService:
              Type: AWS::ECS::Service
              Properties:
                TaskDefinition: "${{ steps.register-task-def.outputs.task-def-arn }}"
                LoadBalancerInfo:
                  ContainerName: "$ECR_REPOSITORY"
                  ContainerPort: 8000
        EOF

        # Create deployment package
        zip -r -j deployment-${{ steps.generate.outputs.image-tag }}.zip appspec.yml ${{ steps.task-def.outputs.task-definition }}

        # Upload to S3
        aws s3 cp deployment-${{ steps.generate.outputs.image-tag }}.zip s3://${{ env.S3_BUCKET }}/deployments/
        
        echo "deployment_key=deployments/deployment-${{ steps.generate.outputs.image-tag }}.zip" >> $GITHUB_OUTPUT

    - name: Create CodeDeploy deployment
      id: codedeploy-deployment
      run: |
        echo "Creating CodeDeploy deployment..."
        
        # Create deployment
        DEPLOYMENT_ID=$(aws deploy create-deployment \
          --application-name $CODEDEPLOY_APPLICATION \
          --deployment-group-name $CODEDEPLOY_DEPLOYMENT_GROUP \
          --revision revisionType=S3,s3Location="{bucket=${{ env.S3_BUCKET }},key=${{ steps.codedeploy-artifacts.outputs.deployment_key }},bundleType=zip}" \
          --description "Blue/Green deployment from GitHub Actions - commit ${{ steps.generate.outputs.image-tag }}" \
          --query 'deploymentId' --output text 2>/dev/null)

        if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "None" ]; then
          echo "CodeDeploy Blue/Green deployment created: $DEPLOYMENT_ID"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
        else
          echo "CodeDeploy Blue/Green deployment failed"
          exit 1
        fi

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-deploy]

    steps:
    - name: Deployment Success Notification
      if: needs.build-and-deploy.result == 'success'
      run: |
        echo "Deployment successful!"
        echo "Application is now running on ECS with blue/green deployment strategy."

    - name: Deployment Failure Notification
      if: needs.build-and-deploy.result == 'failure'
      run: |
        echo "Deployment failed!"
        echo "Please check the logs and fix any issues."
        exit 1
